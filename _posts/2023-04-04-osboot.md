---
title: 基于x86处理器的OS内核启动
date: 2023-04-04
description: 
categories: 
  - OS
  - x86汇编
image: https://s1.ax1x.com/2023/03/12/ppM1bX4.jpg
---

&emsp;&emsp; 本文是对操作系统实验课中的OS内核启动过程部分进行梳理和笔记。实际上计算机开机启动确实是个很有趣的过程。可以设想一下，计算机的启动需要程序来加载，但是计算机没有启动又运行不了程序，这有点像是陷进了先有鸡还是先有蛋的问题。

&emsp;&emsp; 那么计算机到底是如何启动的呢？上述那个先有鸡还是先有蛋的问题最终的解决方案是通过一组固化到主板上的ROM来加载能够启动计算机的程序，并最终完成计算机的启动。现代计算机的启动过程如下图所示：

![iamge](https://s1.ax1x.com/2023/04/04/pp4HD8e.png)

&emsp;&emsp; 上图中，在 **BIOS** 之后的所有程序都是存放在硬盘中，他们需要被分别加载到内存中，才能够被CPU执行。而BIOS会为我们自动加载硬盘中的首个扇区（一个扇区一般是512字节）的内容到内存的0x7c00处执行，这个存放在首扇区的程序就叫做MBR。

&emsp;&emsp; **MBR** 的大小被限制为512字节，能做的事情非常有限。所以这个程序中所做的事情主要是进一步把硬盘中的Bootloader程序<u>加载</u>到内存的0x7e00处并跳转到该程序，

&emsp;&emsp; **Bootloader** 程序则没有大小限制，所以可以做很多初始化工作，并把操作系统的内核（kernel）从硬盘中<u>加载</u>到内存中(地址可以自己设定)并跳转到内核程序。

&emsp;&emsp; **Kernel** 加载完毕。自此，计算机完成了启动，之后我们便可以通过操作系统来和这台电脑交互了。（顺带一提，没有操作系统的电脑称为裸机，只是由一堆硬件组成，我们没有办法进行人机交互）

&emsp;&emsp; 上面提到的从硬盘中<u>加载</u> **Bootloader / Kernel** 到内存中执行，在汇编程序中有两种办法实现。分别是硬盘的LBA(Logical Block Addressing)读取和CHS(Cylinder-Head-Sector 柱面-磁头-扇区)读取, 两种方式实际上只是逻辑编号上不同，前者采取线性编号，后者采取依照硬盘物理构成编号，可以互相转换。

&emsp;&emsp; 这里给出了一个采用LBA模式通过 I/O 端口来读取硬盘的示例：（如果想用CHS，需要依赖于BIOS的int 13H中断）


```nasm
[bits 16]
asm_read_hard_disk:
    push bp
    mov bp, sp
    pushad

    mov ax, [bp + 2 * 3] ; 逻辑扇区低16位

; 0x1f3端口放置LBA地址7~0bit
    mov dx, 0x1f3
    out dx, al

; 0x1f4端口放置LBA地址15~8
    inc dx        ; 0x1f4
    mov al, ah
    out dx, al

; 0x1f5端口放置LBA地址23~16
    xor ax, ax    ; 0x1f5
    inc dx
    out dx, al

; 0x1f5端口 低4位放置LBA地址27~24，高4位是配置信息
    inc dx        ; 0x1f6
    mov al, ah
    and al, 0x0f
    or al, 0xe0   ; 此处高4位置1110 代表 1_LBA_1_主硬盘
    out dx, al

; 0x1f2端口控制读取的扇区数量（最多255）
    mov dx, 0x1f2
    mov al, 1
    out dx, al    ; 读取1个扇区

; 向0x1f7端口写入0x20 请求硬盘读
    mov dx, 0x1f7 ; 0x1f7
    mov al, 0x20  ;读命令
    out dx,al

; 从0x1f7端口读出硬盘状态，0000_1000表示已经准备好交换数据
.waits: ; 等待处理其他操作
    in al, dx     ; dx = 0x1f7
    and al,0x88
    cmp al,0x08
    jnz .waits

; 从0x1f0端口中读取512字节到地址ds:bx
    mov bx, [bp + 2 * 2]
    mov cx, 256   ; 每次读取一个字，2个字节，因此读取256次即可
    mov dx, 0x1f0
.readw: ; 读出2个字节
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .readw

    popad
    pop bp
    ret 
```

&emsp;&emsp; 无论在mbr中加载bootloader 还是在bootloader中加载kernel都可以直接调用这个函数。不过这个函数每次被调用是读出一个扇区，所以如果假设我们的bootloader有5个扇区，我们需要把函数调用放在一个循环体中并为他传递参数：

```nasm
; 初始化栈指针
mov sp, 0x7c00 ; 
mov ax, LOADER_START_SECTOR  ; = 1 MBR是0号扇区，所以Bootloader从1开始
mov cx, LOADER_SECTOR_COUNT  ; = 5 读取的扇区数量
mov bx, LOADER_START_ADDRESS ; = 0x7e00 bootloader中被加载到这个内存地址

; 加载bootloader
load_bootloader: 
    push ax
    push bx
    call asm_read_hard_disk  ; 读取硬盘
    add sp, 4 ; 弹出栈顶2个元素
    inc ax    ; 扇区LBA编号
    add bx, 512
    loop load_bootloader

; 跳转到bootloader
jmp 0x0000:0x7e00        
```

&emsp;&emsp; 值得一提的是，在进入函数之后，我们通过bp寄存器来获取参数，此时栈段的最低4个地址的数据如下：

* [bp + 2 * 3] ：调用asm_read_hard_disk前push进的ax的值
* [bp + 2 * 2] ：调用asm_read_hard_disk前push进的bx的值
* [bp + 2 * 1] ：
* [bp + 2 * 0] ：调用asm_read_hard_disk后push进的原bp的值